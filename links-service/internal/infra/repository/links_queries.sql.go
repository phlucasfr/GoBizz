// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: links_queries.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkCustomSlugExists = `-- name: CheckCustomSlugExists :one
SELECT EXISTS (
    SELECT 1 FROM links
    WHERE custom_slug = $1
)
`

func (q *Queries) CheckCustomSlugExists(ctx context.Context, customSlug pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkCustomSlugExists, customSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkShortURLExists = `-- name: CheckShortURLExists :one
SELECT EXISTS (
    SELECT 1 FROM links
    WHERE short_url = $1
)
`

func (q *Queries) CheckShortURLExists(ctx context.Context, shortUrl string) (bool, error) {
	row := q.db.QueryRow(ctx, checkShortURLExists, shortUrl)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countLinksByCustomer = `-- name: CountLinksByCustomer :one
SELECT COUNT(*) as total
FROM links l
WHERE l.customer_id = $1
`

func (q *Queries) CountLinksByCustomer(ctx context.Context, customerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countLinksByCustomer, customerID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createLink = `-- name: CreateLink :one
INSERT INTO links (
    original_url,
    short_url,
    custom_slug,
    customer_id,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, original_url, short_url, custom_slug, clicks, created_at, updated_at, expires_at, customer_id
`

type CreateLinkParams struct {
	OriginalUrl string             `json:"original_url"`
	ShortUrl    string             `json:"short_url"`
	CustomSlug  pgtype.Text        `json:"custom_slug"`
	CustomerID  pgtype.UUID        `json:"customer_id"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, createLink,
		arg.OriginalUrl,
		arg.ShortUrl,
		arg.CustomSlug,
		arg.CustomerID,
		arg.ExpiresAt,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortUrl,
		&i.CustomSlug,
		&i.Clicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CustomerID,
	)
	return i, err
}

const deleteExpiredLinks = `-- name: DeleteExpiredLinks :exec
DELETE FROM links
WHERE expires_at IS NOT NULL 
AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredLinks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredLinks)
	return err
}

const deleteLink = `-- name: DeleteLink :exec
DELETE FROM links
WHERE id = $1
`

func (q *Queries) DeleteLink(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLink, id)
	return err
}

const getExpiredLinks = `-- name: GetExpiredLinks :many
SELECT id, original_url, short_url, custom_slug, clicks, created_at, updated_at, expires_at, customer_id FROM links
WHERE expires_at IS NOT NULL 
AND expires_at < NOW()
`

func (q *Queries) GetExpiredLinks(ctx context.Context) ([]Link, error) {
	rows, err := q.db.Query(ctx, getExpiredLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.ShortUrl,
			&i.CustomSlug,
			&i.Clicks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.CustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkByCustomSlug = `-- name: GetLinkByCustomSlug :one
SELECT id, original_url, short_url, custom_slug, clicks, created_at, updated_at, expires_at, customer_id FROM links
WHERE custom_slug = $1 LIMIT 1
`

func (q *Queries) GetLinkByCustomSlug(ctx context.Context, customSlug pgtype.Text) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkByCustomSlug, customSlug)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortUrl,
		&i.CustomSlug,
		&i.Clicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CustomerID,
	)
	return i, err
}

const getLinkByID = `-- name: GetLinkByID :one
SELECT id, original_url, short_url, custom_slug, clicks, created_at, updated_at, expires_at, customer_id FROM links
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLinkByID(ctx context.Context, id pgtype.UUID) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkByID, id)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortUrl,
		&i.CustomSlug,
		&i.Clicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CustomerID,
	)
	return i, err
}

const getLinkByShortURL = `-- name: GetLinkByShortURL :one
SELECT id, original_url, short_url, custom_slug, clicks, created_at, updated_at, expires_at, customer_id FROM links
WHERE short_url = $1 LIMIT 1
`

func (q *Queries) GetLinkByShortURL(ctx context.Context, shortUrl string) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkByShortURL, shortUrl)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortUrl,
		&i.CustomSlug,
		&i.Clicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CustomerID,
	)
	return i, err
}

const getLinksByCustomer = `-- name: GetLinksByCustomer :many
SELECT 
    l.id, l.original_url, l.short_url, l.custom_slug, l.clicks, l.created_at, l.updated_at, l.expires_at, l.customer_id,
    COUNT(*) OVER() as total_count
FROM links l
WHERE l.customer_id = $1
    AND ($4::text IS NULL OR 
        LOWER(l.original_url) LIKE '%' || LOWER($4) || '%' OR
        (l.custom_slug IS NOT NULL AND LOWER(l.custom_slug) LIKE '%' || LOWER($4) || '%')
    )
    AND ($5::text IS NULL OR 
        CASE 
            WHEN $5 = 'active' THEN (l.expires_at IS NULL OR l.expires_at > NOW())
            WHEN $5 = 'expired' THEN (l.expires_at IS NOT NULL AND l.expires_at <= NOW())
            ELSE true
        END
    )
    AND ($6::text IS NULL OR 
        CASE 
            WHEN $6 = 'custom' THEN l.custom_slug IS NOT NULL
            WHEN $6 = 'auto' THEN l.custom_slug IS NULL
            ELSE true
        END
    )
ORDER BY 
    CASE $7::text
        WHEN 'clicks' THEN l.clicks::text
        WHEN 'created_at' THEN l.created_at::text
        WHEN 'original_url' THEN l.original_url
        WHEN 'expiration_date' THEN 
            CASE 
                WHEN l.expires_at IS NULL THEN '9999-12-31'::text
                ELSE l.expires_at::text
            END
        ELSE l.created_at::text
    END
    DESC
LIMIT NULLIF($2, 0)
OFFSET COALESCE($3, 0)
`

type GetLinksByCustomerParams struct {
	CustomerID pgtype.UUID `json:"customer_id"`
	Column2    interface{} `json:"column_2"`
	Column3    interface{} `json:"column_3"`
	Column4    string      `json:"column_4"`
	Column5    string      `json:"column_5"`
	Column6    string      `json:"column_6"`
	Column7    string      `json:"column_7"`
}

type GetLinksByCustomerRow struct {
	ID          pgtype.UUID        `json:"id"`
	OriginalUrl string             `json:"original_url"`
	ShortUrl    string             `json:"short_url"`
	CustomSlug  pgtype.Text        `json:"custom_slug"`
	Clicks      int32              `json:"clicks"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CustomerID  pgtype.UUID        `json:"customer_id"`
	TotalCount  int64              `json:"total_count"`
}

func (q *Queries) GetLinksByCustomer(ctx context.Context, arg GetLinksByCustomerParams) ([]GetLinksByCustomerRow, error) {
	rows, err := q.db.Query(ctx, getLinksByCustomer,
		arg.CustomerID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksByCustomerRow
	for rows.Next() {
		var i GetLinksByCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.ShortUrl,
			&i.CustomSlug,
			&i.Clicks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.CustomerID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLink = `-- name: UpdateLink :one
UPDATE links
SET 
    original_url = COALESCE($1, original_url),
    short_url = COALESCE($2, short_url),
    custom_slug = COALESCE($3, custom_slug),
    expires_at = $4
WHERE id = $5
RETURNING id, original_url, short_url, custom_slug, clicks, created_at, updated_at, expires_at, customer_id
`

type UpdateLinkParams struct {
	OriginalUrl string             `json:"original_url"`
	ShortUrl    string             `json:"short_url"`
	CustomSlug  pgtype.Text        `json:"custom_slug"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	ID          pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateLink(ctx context.Context, arg UpdateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, updateLink,
		arg.OriginalUrl,
		arg.ShortUrl,
		arg.CustomSlug,
		arg.ExpiresAt,
		arg.ID,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortUrl,
		&i.CustomSlug,
		&i.Clicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CustomerID,
	)
	return i, err
}

const updateLinkClicks = `-- name: UpdateLinkClicks :one
UPDATE links
SET clicks = clicks + 1
WHERE id = $1
RETURNING id, original_url, short_url, custom_slug, clicks, created_at, updated_at, expires_at, customer_id
`

func (q *Queries) UpdateLinkClicks(ctx context.Context, id pgtype.UUID) (Link, error) {
	row := q.db.QueryRow(ctx, updateLinkClicks, id)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortUrl,
		&i.CustomSlug,
		&i.Clicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CustomerID,
	)
	return i, err
}
